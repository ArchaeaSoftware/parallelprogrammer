/*
 *
 * nf4.cpp
 *
 * Fun AVX512 implementation of NF4 quantization.
 *
 * Build with: g++ -march=native nf4.cpp
 *
 * Copyright (c) 2025, Archaea Software, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions 
 * are met: 
 *
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in 
 *    the documentation and/or other materials provided with the 
 *    distribution. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE 
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN 
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <math.h>
#include <memory.h>
#include <assert.h>

#include <x86intrin.h>

constexpr float NF4_LUT[16] = {
    -1.0,
    -0.6961928009986877,
    -0.5250730514526367,
    -0.39491748809814453,
    -0.28444138169288635,
    -0.18477343022823334,
    -0.09105003625154495,
    0.0,
    0.07958029955625534,
    0.16093020141124725,
    0.24611230194568634,
    0.33791524171829224,
    0.44070982933044434,
    0.5626170039176941,
    0.7229568362236023,
    1.0
};

constexpr float NF4_LUT_mid[16] = {
    0.0f,
    NF4_LUT[ 0] + 0.5f * ( NF4_LUT[ 1] - NF4_LUT[ 0] ),
    NF4_LUT[ 1] + 0.5f * ( NF4_LUT[ 2] - NF4_LUT[ 1] ),
    NF4_LUT[ 2] + 0.5f * ( NF4_LUT[ 3] - NF4_LUT[ 2] ),
    NF4_LUT[ 3] + 0.5f * ( NF4_LUT[ 4] - NF4_LUT[ 3] ),
    NF4_LUT[ 4] + 0.5f * ( NF4_LUT[ 5] - NF4_LUT[ 4] ),
    NF4_LUT[ 5] + 0.5f * ( NF4_LUT[ 6] - NF4_LUT[ 5] ),
    NF4_LUT[ 6] + 0.5f * ( NF4_LUT[ 7] - NF4_LUT[ 6] ),
    NF4_LUT[ 7] + 0.5f * ( NF4_LUT[ 8] - NF4_LUT[ 7] ),
    NF4_LUT[ 8] + 0.5f * ( NF4_LUT[ 9] - NF4_LUT[ 8] ),
    NF4_LUT[ 9] + 0.5f * ( NF4_LUT[10] - NF4_LUT[ 9] ),
    NF4_LUT[10] + 0.5f * ( NF4_LUT[11] - NF4_LUT[10] ),
    NF4_LUT[11] + 0.5f * ( NF4_LUT[12] - NF4_LUT[11] ),
    NF4_LUT[12] + 0.5f * ( NF4_LUT[13] - NF4_LUT[12] ),
    NF4_LUT[13] + 0.5f * ( NF4_LUT[14] - NF4_LUT[13] ),
    NF4_LUT[14] + 0.5f * ( NF4_LUT[15] - NF4_LUT[14] ),
};

inline
unsigned char
dQuantizeNF4_0(float x)
{
  // the values for this tree was generated by test_normal_map_tree
  // in the file tests/test_functional.py
  if(x > 0.03979014977812767f)
    if(x > 0.3893125355243683f) // 1
      if(x > 0.6427869200706482f) // 11
        if(x > 0.8614784181118011f) // 111
          return 0b1111;
        else
          return 0b1110;
      else
        if(x > 0.5016634166240692f) // 110
          return 0b1101;
        else
          return 0b1100;
    else
      if(x > 0.2035212516784668f) // 10
        if(x > 0.2920137718319893f) // 101
          return 0b1011;
        else
          return 0b1010;
      else
        if(x > 0.1202552504837513f) // 100
          return 0b1001;
        else
          return 0b1000;
  else
    if(x > -0.33967943489551544f) // 0
      if(x > -0.13791173323988914f) // 01
        if(x > -0.045525018125772476f) // 011
          return 0b0111;
        else
          return 0b0110;
      else
        if(x > -0.23460740596055984f) // 010
          return 0b0101;
        else
          return 0b0100;
    else
      if(x > -0.6106329262256622f) // 00
        if(x > -0.4599952697753906f) // 001
          return 0b0011;
        else
          return 0b0010;
      else
        if(x > -0.8480964004993439f) // 000
          return 0b0001;
        else
          return 0b0000;
}

inline
unsigned char
dQuantizeNF4_1(float x)
{
  // the values for this tree was generated by test_normal_map_tree
  // in the file tests/test_functional.py
  if(x > NF4_LUT_mid[0b1000] )
    if(x > NF4_LUT_mid[0b1100]) // 1
      if(x > NF4_LUT_mid[0b1110]) // 11
        if(x > NF4_LUT_mid[0b1111]) // 111
          return 0b1111;
        else
          return 0b1110;
      else
        if(x > NF4_LUT_mid[0b1101]) // 110
          return 0b1101;
        else
          return 0b1100;
    else
      if(x > NF4_LUT_mid[0b1010] ) // 10
        if(x > NF4_LUT_mid[0b1011] ) // 101
          return 0b1011;
        else
          return 0b1010;
      else
        if(x > NF4_LUT_mid[0b1001] ) // 100
          return 0b1001;
        else
          return 0b1000;
  else
    if(x > NF4_LUT_mid[0b0100]) // 1
      if(x > NF4_LUT_mid[0b0110]) // 11
        if(x > NF4_LUT_mid[0b0111]) // 111
          return 0b0111;
        else
          return 0b0110;
      else
        if(x > NF4_LUT_mid[0b0101]) // 110
          return 0b0101;
        else
          return 0b0100;
    else
      if(x > NF4_LUT_mid[0b0010] ) // 10
        if(x > NF4_LUT_mid[0b0011] ) // 101
          return 0b0011;
        else
          return 0b0010;
      else
        if(x > NF4_LUT_mid[0b0001] ) // 100
          return 0b0001;
        else
          return 0b0000;
}


int
float_to_NF4_0( const float *base, size_t N, float f )
{
    int ret = 0;
    float diff = fabsf( base[0]-f );
    for ( size_t i = 1; i < 16; i++ ) {
        float thisdiff = fabsf( base[i]-f );
        if ( thisdiff < diff ) {
            diff = thisdiff;
            ret = i;
        }
    }
    return ret;
}

int
float_to_NF4_mid( const float *base, size_t N, float f )
{
    int i = 0;
    if ( f >= base[i+8] ) i += 8;
    if ( f >= base[i+4] ) i += 4;
    if ( f >= base[i+2] ) i += 2;
    if ( f >= base[i+1] ) i += 1;
    return i;
}

int
float_to_NF4_1( const float *base, size_t N, float f )
{
    int i = 0;
    if ( f >= base[i+8] ) i += 8;
    if ( f >= base[i+4] ) i += 4;
    if ( f >= base[i+2] ) i += 2;
    if ( f >= base[i+1] ) i += 1;
//    return i + ((base[i+1]-f)<(f-base[i]));
    int ret = i + ((base[i+1]-f)<(f-base[i]));
    if ( ret != float_to_NF4_mid( NF4_LUT_mid, N, f ) ) {
        asm("int $3;");
    }
    return ret;
}


void
float_to_NF4_16( uint32_t *out, const float *base, size_t N, const float *f )
{
  __m512i v_i = _mm512_setzero_si512();
  __m512 v_f = _mm512_load_ps( f );
  const __m512 v_lut = _mm512_loadu_ps( &NF4_LUT_mid[0] );

  auto round = [v_lut, &v_i, v_f]( int N2 ) -> void {
    __m512i v_i_N2 = _mm512_add_epi32( v_i, _mm512_set1_epi32( N2 ) );
    __m512 v_lut_i_N2 = _mm512_permutexvar_ps( v_i_N2, v_lut );
    __mmask16 mask_gt = _mm512_cmp_ps_mask( v_f, v_lut_i_N2, _CMP_GE_OS );
    v_i = _mm512_mask_add_epi32( v_i, mask_gt, v_i, _mm512_set1_epi32( N2 ) );
  };

  round( 8 );
  round( 4 );
  round( 2 );
  round( 1 );

  _mm512_store_si512( (__m512i *) out, v_i );
}

#if 0
// works
void
float_to_NF4_16( uint32_t *out, const float *base, size_t N, const float *f )
{
  __m512i v_i = _mm512_setzero_si512();
  __m512 v_f = _mm512_load_ps( f );
  const __m512 v_lut = _mm512_loadu_ps( &NF4_LUT[0] );

  auto round = [v_lut, &v_i, v_f]( int N2 ) -> void {
    __m512i v_i_N2 = _mm512_add_epi32( v_i, _mm512_set1_epi32( N2 ) );
    __m512 v_lut_i_N2 = _mm512_permutexvar_ps( v_i_N2, v_lut );
    __mmask16 mask_gt = _mm512_cmp_ps_mask( v_f, v_lut_i_N2, _CMP_GE_OS );
    v_i = _mm512_mask_add_epi32( v_i, mask_gt, v_i, _mm512_set1_epi32( N2 ) );
  };

  round( 8 );
  round( 4 );
  round( 2 );
  round( 1 );

  __m512 v_lut_i = _mm512_permutexvar_ps( v_i, v_lut );
  __m512i v_i_p1 = _mm512_add_epi32( v_i, _mm512_set1_epi32( 1 ) );
  __m512 v_lut_i_1 = _mm512_permutexvar_ps( v_i_p1, v_lut );
  __m512 v_lodist = _mm512_sub_ps( v_f, v_lut_i );
  __m512 v_hidist = _mm512_sub_ps( v_lut_i_1, v_f );
  __mmask16 hi_gt_lo = _mm512_cmp_ps_mask( v_lodist, v_hidist, _CMP_GT_OS );
  v_i = _mm512_mask_add_epi32( v_i, hi_gt_lo, v_i, _mm512_set1_epi32( 1 ) );
  _mm512_store_si512( (__m512i *) out, v_i );
}
#endif

#if 0
// started an AVX2 implementation
void
float_to_NF42_8( uint32_t *out, const float *base, size_t N, const float *f, const uint32_t *gold )
{
    __m256i m_i = _mm256_setzero_si256();
    __m256 m_f = _mm256_load_ps( f );
    const __m256 m_nf4_lut0 = _mm256_loadu_ps( &NF4_LUT[0] );
    const __m256 m_nf4_lut1 = _mm256_loadu_ps( &NF4_LUT[7] );

    __m256 m_f_gt_0 = _mm256_cmp_ps( _mm256_setzero_ps(), m_f, _CMP_GT_OS );
    __m256 m_lut = _mm256_blendv_ps( m_nf4_lut0, m_nf4_lut1, m_f_gt_0 );
    __m256i m_i0 = _mm256_blendv_epi8( _mm256_setzero_si256(), _mm256_set1_epi32( 7 ), _mm256_castps_si256( m_f_gt_0 ) );

    auto binsearch = []( const float *base, float f ) -> int {
        int i = 0;
        if ( f >= base[i+4] ) i += 4;
        if ( f >= base[i+2] ) i += 2;
        if ( f >= base[i+1] ) i += 1;
        return i;
    };

    auto round = [m_lut, &m_i, m_f]( int N2 ) -> void {
        __m256i m_i_N2 = _mm256_add_epi32( m_i, _mm256_set1_epi32( N2 ) );
        __m256 m_lut_i_N2 = _mm256_permutevar8x32_ps( m_lut, m_i_N2 );
               m_i_N2 = _mm256_castps_si256( _mm256_andnot_ps( _mm256_cmp_ps( m_lut_i_N2, m_f, _CMP_GT_OS ), _mm256_castsi256_ps( m_i_N2 ) ) );
        m_i = _mm256_add_epi32( m_i, m_i_N2 );
    };

    round( 4 );
    round( 2 );
    round( 1 );
    __m256i m_i_1 = _mm256_add_epi32( m_i, _mm256_set1_epi32( 1 ) );
    __m256 m_lut_i = _mm256_permutevar8x32_ps( m_lut, m_i );
    __m256 m_lut_i_1 = _mm256_permutevar_ps( m_lut, m_i_1 );
    __m256 m_hi_m_f = _mm256_sub_ps( m_lut_i_1, m_f );
    __m256 m_f_m_lo = _mm256_sub_ps( m_f, m_lut_i );
    __m256i m_inc = _mm256_castps_si256( _mm256_cmp_ps( m_f_m_lo, m_hi_m_f, _CMP_GT_OS ) );
    m_i = _mm256_add_epi32( m_i0, _mm256_sub_epi32( m_i, m_inc ) );
    _mm256_store_si256( (__m256i *) out, m_i );
}
#endif

// this function implements a scalar version of the AVX2 implementation strategy
int
float_to_NF4_2( const float *base, size_t N, float f )
{
    auto closest_index = []( float lo, float hi, float f, int loidx ) -> int {
        return loidx + ((hi-f)<(f-lo));
    };
    auto binsearch = []( const float *base, float f ) -> int {
        int i = 0;
        if ( f >= base[i+4] ) i += 4;
        if ( f >= base[i+2] ) i += 2;
        if ( f >= base[i+1] ) i += 1;
        return i;
    };

    int i;
    if ( f < 0.0f ) i = binsearch( base, f );
    else i = 7+binsearch( base+7, f );
    return closest_index( base[i], base[i+1], f, i );
}

int
float_to_NF4_3( const float *base, size_t N, float f )
{
    uint8_t ret0 = dQuantizeNF4_0( f );
    uint8_t ret1 = dQuantizeNF4_1( f );
    if ( ret0 != ret1 ) {
        asm("int $3;");
    }
    return ret0;
}

int
main()
{
    int hist[16];
    memset( &hist[0], 0, sizeof(hist) );

    constexpr size_t N = 1048576;
    alignas(64) static float in[N];
    alignas(64) static uint32_t inx0[N], inx1[N];

    uint64_t start, stop;

    for ( size_t i = 0; i < N; i++ ) {
        float f = (float) rand() / RAND_MAX;
        if ( rand() & 1 ) f = -f;
        in[i] = f;
    }

    start = __rdtsc();
    for ( size_t i = 0; i < N; i++ ) {
        inx0[i] = float_to_NF4_0( NF4_LUT, 16, in[i] );
        hist[inx0[i]] += 1;
    }
    stop = __rdtsc();
    printf( "gold: %.2f clocks/iteration\n", (double) (stop-start)/N );

    start = __rdtsc();
    for ( size_t i = 0; i < N; i++ ) {
        inx0[i] = float_to_NF4_1( NF4_LUT, 16, in[i] );
        hist[inx0[i]] += 1;
    }
    stop = __rdtsc();
    printf( "binsearch: %.2f clocks/iteration\n", (double) (stop-start)/N );

    start = __rdtsc();
    for ( size_t i = 0; i < N; i++ ) {
        inx1[i] = float_to_NF4_3( NF4_LUT, 16, in[i] );
    }
    stop = __rdtsc();
    printf( "bitsandbytes: %.2f clocks/iteration\n", (double) (stop-start)/N );

/*
    for ( size_t i = 0; i < N; i++ ) {
        inx1[i] = float_to_NF4_2( NF4_LUT, 16, in[i] );
    }
*/

    start = __rdtsc();
    for ( size_t i = 0; i < N/16; i++ ) {
        float_to_NF4_16( inx1+i*16, NF4_LUT, 16, in+i*16 );
    }
    stop = __rdtsc();
    printf( "AVX512: %.2f clocks/iteration\n", (double) (stop-start)/N );

    int numErrors = 0;
    for ( size_t i = 0; i < N; i++ ) {
        if ( inx0[i] != inx1[i] ) {
            printf( "Mismatch: %u should be %u\n", inx1[i], inx0[i] );
            inx0[i] = float_to_NF4_0( NF4_LUT, 16, in[i] );
            inx1[i] = float_to_NF4_3( NF4_LUT, 16, in[i] );
            numErrors += 1;
        }
    }
    for ( int i = 0; i < 16; i++ ) {
        printf( "%d\t%d\n", i, hist[i] );
    }
    printf( "%d errors\n", numErrors );
    return 0;
}

